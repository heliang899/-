[TOC]



# 1.链表篇

## 1. 203 移除链表元素

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
// 不使用伪头 ,删除头结点和非头结点 分开写
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //删除头结点
        while( head != nullptr && head->val == val ){
            ListNode* tmp = head;
            head = head->next;
            delete tmp;
        }
        //删除非头结点
        ListNode* cur = head;
        while( cur != nullptr && cur->next != nullptr){
            if( cur->next->val == val ){
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            }
            else{
                cur = cur->next;
            }
        }
        return head;
    }
};


```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //设置虚拟头节点
        ListNode* dumhead = new ListNode(0);
        dumhead->next = head;
        ListNode* cur = dumhead;
        while( cur->next !=nullptr  ){
            if(cur->next->val == val){
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            }
            else{
                cur = cur->next;
            }
        }
        return dumhead->next;
    }
};
```

## 2. 707 设计链表

### 1) 设计单链表

```c++
class MyLinkedList {
private:
    struct Node{
        int val;
        Node* next;
        Node():val(0),next(nullptr){}
        Node(int _val):val(_val),next(nullptr){}
    };
    Node* dumhead;
    int size;
public:
    /** Initialize your data structure here. */
    MyLinkedList() {
        dumhead = new Node(0);
        size = 0;
    }
    
    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
    int get(int index) {
        Node* cur = dumhead->next;
        if( index >= 0 && index < size){
            while(  index-- ){
                cur = cur->next;
            }
            return cur->val;
        }
        else return -1;
    }
    
    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
    void addAtHead(int val) {
        Node* node = new Node(val);
        if(size > 0)    node->next = dumhead->next;
        dumhead->next = node;
        size++;
    }
    
    /** Append a node of value val to the last element of the linked list. */
    void addAtTail(int val) {
        Node* cur = dumhead;
        Node* node = new Node(val);
        while( cur->next != nullptr ){
            cur = cur->next;
        }
        cur->next = node;
        size++;
    }
    
    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
    void addAtIndex(int index, int val) {
        if( index > size ) return;
        Node* cur = dumhead;
        while( index-- ){
            cur = cur->next;
        }
        Node* node = new Node(val);
        node->next = cur->next;
        cur->next = node;
        size++;
    }
    
    /** Delete the index-th node in the linked list, if the index is valid. */
    void deleteAtIndex(int index) {
        if( index >= 0 && index < size){
            Node* cur = dumhead;
            while( index-- ){
                cur = cur->next;
            }
            Node* tmp = cur->next;
            cur->next = cur->next->next;
            size--; 
            delete tmp;
        }       
    }
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

### 2) 设计双链表

```c++
class MyLinkedList {
private:
    struct Node{
        int val;
        Node* next;
        Node* pre;
        Node():val(0),next(nullptr),pre(nullptr){}
        Node(int _val):val(_val),next(nullptr),pre(nullptr){}
    };
    Node* dumhead;
    Node* dumtail;
    int size;
public:
    /** Initialize your data structure here. */
    MyLinkedList() {
        dumhead = new Node(0);
        dumtail = new Node(0);
        dumhead->next = dumtail;
        dumtail->pre = dumhead;
        size = 0;
    }
    
    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
    int get(int index) {
        if( index < 0 || index >= size ) return -1;
        if( index < size/2 ){
            Node* cur = dumhead;
            while( index-- ) cur = cur->next;
            cur = cur->next;
            return cur->val;
        }
        else{
            Node* cur = dumtail;
            index = size - index;
            while( index-- ) cur = cur->pre;
            return cur->val;
        }  
    }
    
    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
    void addAtHead(int val) {
        Node* node = new Node(val);
        node->next = dumhead->next;
        node->pre = dumhead;
        dumhead->next->pre = node;
        dumhead->next = node;
        size++;
    }
    
    /** Append a node of value val to the last element of the linked list. */
    void addAtTail(int val) {
        Node* node = new Node(val);
        node->next = dumtail;
        node->pre = dumtail->pre;
        dumtail->pre->next = node;
        dumtail->pre = node;
        size++;
    }
    
    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
    void addAtIndex(int index, int val) {
        if( index > size ) return;
        Node* cur;
        if( index < size/2 ){
            cur = dumhead;
            while( index-- ) cur = cur->next;
        }
        else{
            cur = dumtail;
            index = size - index + 1;
            while( index-- ) cur = cur->pre;
        }
        Node* node = new Node(val);
        node->pre = cur;
        node->next = cur->next;
        cur->next->pre = node;
        cur->next = node;
        size++;
    }
    
    /** Delete the index-th node in the linked list, if the index is valid. */
    void deleteAtIndex(int index) {
        if( index < 0 || index >= size ) return;
        Node* cur;
        if( index < size/2 ){
            cur = dumhead;
            while( index-- ) cur = cur->next;
        }
        else{
            cur = dumtail;
            index = size - index + 1;
            while( index-- ) cur = cur->pre;
        }   
        Node* tmp = cur->next;
        cur->next->next->pre = cur;
        cur->next = cur->next->next;
        delete tmp;
        size--;
    }
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

## 3. 206 反转链表

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* cur = head;
        ListNode* pre = nullptr;
        while( cur != nullptr ){
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
```

## 4. 两两交换链表中的节点

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // exampale :    dumhead->1->2->3->4->NULL
    ListNode* swapPairs(ListNode* head) {
        ListNode* dumhead = new ListNode(0);
        dumhead->next = head;
        ListNode* cur = dumhead;
        while( cur->next != nullptr && cur->next->next != nullptr ){
            ListNode* tmp = cur->next; //1
            ListNode* tmp1 = cur->next->next->next;// 3
            cur->next = cur->next->next; // cur->2  步骤1
            tmp->next = tmp1; 			 // 1->3    步骤2
            cur->next->next = tmp;  	 // 2->1	步骤3
            cur = tmp;
        }
        return dumhead->next;
    }
};
```

## 5. 删除链表倒数第N个节点

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dumhead = new ListNode(0);
        dumhead->next = head;
        ListNode* fast = dumhead;
        ListNode* slow = dumhead;
        while( n-- ) fast = fast->next;
        while( fast->next != nullptr ){
            fast = fast->next;
            slow = slow->next;
        }
        ListNode* tmp = slow->next;
        slow->next = slow->next->next;
        delete tmp;
        return dumhead->next;
    }
};
```

## 6. 链表相交

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
//思路： A + B , B + A  注意 (A == NULL && B != NULL) 时, A跳转至 headB;
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* A = headA;
        ListNode* B = headB;
        while( A != NULL && B != NULL ){
            if(A == B ) return A;
            A = A->next;
            B = B->next;
            if(A == NULL && B != NULL) A = headB;
            if(B == NULL && A != NULL) B = headA;
        }
        return NULL;
    }
};
```

## 7. 寻找链表环入口-[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

如下图所示，设链表中环外部分的长度为 a。**slow** 指针进入环后，又走了 b的距离与**fast** 相遇。此时，**fast** 指针已经走完了环的 n 圈，因此**fast**走过的总距离为 **a+n(b+c)+b=*a*+(*n*+1)*b*+*n*c**。

![](C:\Users\38032\Desktop\note\寻找链表环入口示意图.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
// 思路: x = (y+z)(n-1)+z; 1.快慢指针第一次相遇。 2. 定义cur指针到头节点，同时移动cur与slow相遇，即为入口。
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while( fast != NULL && fast->next != NULL ){
            fast = fast->next->next;
            slow = slow->next;
            if(fast == slow){
                ListNode* cur = head;
                while( cur != slow ){
                    cur = cur->next;
                    slow = slow->next;
                }
                return cur;
            }
        }    
        return NULL;
    }
};
```

## 8.[83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* cur = head;
		while ( cur && cur->next ) {
            if ( cur->val == cur->next->val ) {
                cur->next = cur->next->next;
            }
            else {
                cur = cur->next;
            }
        }
        return head;
    }
};
```

## 9.[82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* dummuy = new ListNode(0,head);
        ListNode* cur = dummuy;
        while ( cur->next && cur->next->next ) {
            if ( cur->next->val == cur->next->next->val ) {
                 int x = cur->next->val;
         		 while ( cur->next && cur->next->val == x  ) {
                    cur->next = cur->next->next;
            	 }       
            }
            else {
                 cur = cur->next;
            }
        }
		return dummuy->next;
    }
};
```



# 2.哈希表篇

## 2. 242 有效的字母异位词

```c++
//思路：哈希表计数
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        for(auto c : s){
            record[c-'a']++;
        }
        for(auto c : t){
            record[c-'a']--;
        }
        for(int i = 0;i < 26;i++ ){
            if( record[i] != 0)
                return false;
        }
        return true;
    }
};
```

## 3. 349 两个有序数组的交集

```c++
//思路 排序+双指针

class Solution{
public:
	vector<int> intersection(vector<int>nums1,vector<int>nums2){
		sort(nums1.begin(),nums1.end());
		sort(nums2.begin(),nums2.end());
		int lenth1 = nums1.size(),lenth2 = nums2.size();
		int index1 = 0,index2 = 0;
		vector<int> ans;
		while( index1 < lenth1 && index2 < lenth2){
			int num1 = nums1[index1],num2 = nums2[index2];
			if( num1 == num2 ){
				if( ans.empty() || num1 != ans.back() )
					ans.push_back(num1);
                index1++;
                index2++;
			}
			else if( num1 < num2 ){
				index1++;
			}
			else index2++;
		}
		return ans;
	} 
};
```

## 4. 202 快乐数

```c++
/* 思路: 最终会得到 1,最终会进入循环。*/
class Solution {
public:
    int getnext(int n){
        int ans = 0;
        while(n > 0){
            ans += pow(n%10,2);
            n /= 10;            
        }
        return ans;
    }

    bool isHappy(int n) {
        unordered_set<int> s;
        while( n != 1 && s.find(n) == s.end() ){
            s.emplace(n); 
            n = getnext(n);
        }
        return n == 1;
    }
};
```

## 5. 1 两数之和、三数之和、四数之和

```c++
// 哈希表
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int>mp;
        for(int i = 0;i < nums.size();i++ ){
            int tmp = target - nums[i];
            if(  mp.find(tmp) != mp.end() &&  mp[tmp] != i ){
                return vector<int>{mp[tmp],i};
            }
            else mp.emplace(nums[i],i);
        }
        return {};
    }
};
```

```c++
//三数之和, 思路：当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2)减少至 O(N)。

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        sort(nums.begin(),nums.end());
        int n = nums.size();
        for(int first = 0;first < n;first++ ){
            if ( first != 0 && nums[first] == nums[first - 1] ) continue; //避免枚举重复元素
            int third = n - 1;
            int target = -nums[first];
            for(int second = first + 1;second < n;second++ ){
                if ( second != first + 1 && nums[second] == nums[second - 1] ) continue;//避免枚举重复元素
                while( second < third && nums[second] + nums[first] + nums[third] > 0 ){
                    third--;
                }
                if( second == third ) break;
                if( nums[second] + nums[third] == target ){
                    ans.push_back({nums[first],nums[second],nums[third]});
                }
            }
        }
        return ans;
    }
};
```

```c++
//四数之和 ，思路类似于三数之和
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> ans;
        sort(nums.begin(),nums.end());
        int n = nums.size();
        if(n < 4 ) return ans;
        for(int first = 0;first < n - 3;first++ ){
            if(first > 0 && nums[first] == nums[first - 1]) continue;
            if (nums[first] + nums[first + 1] + nums[first + 2] + nums[first + 3] > target) break;
            if (nums[first] + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue;
            for(int second = first + 1;second < n - 2;second++ ){
                if(second > first + 1 && nums[second] == nums[second - 1]) continue;
                if (nums[first] + nums[second] + nums[second + 1] + nums[second + 2] > target) break;
                if (nums[first] + nums[second] + nums[n - 2] + nums[n - 1] < target) continue;
                int third = second + 1; 
                int four = n - 1;
                while( third < four ){
                   int sum = nums[first] + nums[second] + nums[third] + nums[four];
                    if( sum == target){
                        ans.push_back({nums[first],nums[second],nums[third],nums[four]});
                        while( third < four && nums[third] == nums[third+1] ) third++;
                        third++;
                        while( third < four && nums[four] == nums[four-1] ) four--;
                        four--;
                    }
                    else if( sum > target ) four--;
                    else third++;
                }
            }
        }
        return ans;
    }
};
```

## 6. [981. 基于时间的键值存储](https://leetcode-cn.com/problems/time-based-key-value-store/)

```go
class TimeMap {
    unordered_map<string, vector<pair<int, string>>> m;

public:
    TimeMap() {}

    void set(string key, string value, int timestamp) {
        m[key].emplace_back(timestamp, value);
    }

    string get(string key, int timestamp) {
        auto &pairs = m[key];
        // 使用一个大于所有 value 的字符串，以确保在 pairs 中含有 timestamp 的情况下也返回大于 timestamp 的位置
        pair<int, string> p = {timestamp, string({127})};
        auto i = upper_bound(pairs.begin(), pairs.end(), p);
        if (i != pairs.begin()) {
            return (i - 1)->second;
        }
        return "";
    }
};

```



# 3.数组

## 1. 704 二分查找

```c++
//输入数组:严格单调递增
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int end = nums.size()-1;
        int begin = 0;
        while( begin <= end ){
            int mid = begin + (end - begin)/2;
            if( nums[mid] < target ) begin = mid + 1;
            else if( nums[mid] > target ) end = mid - 1;
            else if( nums[mid] == target) return mid;
        }
        return -1;
    }
};
```

## 2. 34 在排序数组中查找元素的第一个和最后一个位置

```c++
class Solution {
public:
    int lower_bound(vector<int>& nums,int target){
        int r = nums.size() - 1;
        int l = 0;
        while( l <= r ){
            int mid = l + (r - l)/2;
            if( nums[mid] < target ) l = mid + 1;
            else if( nums[mid] > target ) r = mid - 1;
            else if( nums[mid] == target ) r = mid - 1;  
        }
        //注意处理边界问题
        if( l >= nums.size() || nums[l] != target  ) return -1;
        return l;
    }

    int upper_bound(vector<int>& nums,int target){
        int r = nums.size() - 1;
        int l = 0;
        while( l <= r ){
            int mid = l + (r - l)/2;
            if( nums[mid] < target ) l = mid + 1;
            else if( nums[mid] > target ) r = mid - 1;
            else if( nums[mid] == target ) l = mid + 1;
        }
        //注意处理边界问题
        if( r < 0 || nums[r] != target ) return -1;
        return r;
    }
    
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.size() == 0) return {-1,-1};
        return vector<int>{lower_bound(nums,target),upper_bound(nums,target)};
    }
};
```

## 3. 27 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left = 0, right = nums.size();
        while (left < right) {
            if (nums[left] == val) {
                nums[left] = nums[right - 1];
                right--;
            } else {
                left++;
            }
        }
        return left;
    }
};

```

## 4. 977 有序数组的平方

```c++
//双指针,指向数组两端，计算平方值，在比较。
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        if( n == 0) return {};
        if( n == 1) return vector<int>{nums[0]*nums[0]};
        vector<int>ans(n,0);

        int pos = 0;
        int l = 0,r = 1;
         for(int i = 0;i < n-1; i++){
              if(nums[i] < 0 ){
                   l = i;
                   r = i+1;
               }
               else break;
          }
          while( l >= 0 || r < n){
               if( l < 0){
                  ans[pos++] = nums[r] * nums[r];
                  r++;
               }
               else if( r == n){
                   ans[pos++] = nums[l] * nums[l];
                   l--;
               }
               else if( nums[l] * nums[l] < nums[r] * nums[r] ){
                   ans[pos++] = nums[l] * nums[l];
                   l--;
               }
               else if( nums[l] * nums[l] >= nums[r] * nums[r] ){
                   ans[pos++] = nums[r] * nums[r];
                   r++;
               }
           }
        return ans;
    }
};
```

## 5. 长度最小的子数组

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        int l = 0;
        int r = -1;
        int sum = 0;
        int ans = INT_MAX;
        while( l <= r || r == -1 ){
            while( sum < target && r < n -1){
                r++;
                sum += nums[r];
            }
            if( sum >= target ){
                int tmp = r - l + 1;
                if( ans > tmp ) ans = tmp;
            }
            sum -= nums[l];
            l++;
        }
        return ans == INT_MAX? 0:ans;
    }
};
```

```c++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            while (sum >= s) {
                ans = min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return ans == INT_MAX ? 0 : ans;
    }
};

```

## 6. 59 螺旋矩阵

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 每一圈循环，需要控制每一条边遍历的长度
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j = starty; j < starty + n - offset; j++) {
                res[startx][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i = startx; i < startx + n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 2;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};

```





# 4.字符串

## 1. 大数加减法

```c++

//"123456789123456789123456789-1234567891456789"
//            1234567891456789
#include<iostream>
#include<string>
#include<string.h>
#include<stack>
#include<queue>
#include<map>
#include<set>
#include<vector>
#include<algorithm> 
#define ll long long
using namespace std;

string addstring(string s1, string s2) {
    int i = s1.length() - 1;
    int j = s2.length() - 1;
    int add = 0;
    string ss = "";
    while (i >= 0 || j >= 0|| add != 0) {
        if (i >= 0)
            add = add + s1[i--] - '0';
        if (j >= 0)
            add = add + s2[j--] - '0';
        ss = ss + to_string(add % 10);
        add = add / 10;
    }
    reverse(ss.begin(), ss.end());
    return ss;
}

//大数减法 
string sub(string s1,string s2){
	bool minus = false;
	if( s1 < s2 ){
		swap(s1,s2);
		minus = true; 
	}
	int i = s1.size() - 1;
	int j = s2.size() - 1;
	int flag = 0;  
	string ans = "";
	while( i >= 0 && j >= 0 ){
		int tmp = tmp - flag;
		if( s1[i] >= s2[j] ){
			tmp = s1[i] - s2[j];
			ans += to_string(tmp);
			flag = 0;
		}
		else{
			tmp = s1[i] - s2[j] + 10;
			ans += to_string(tmp);
			flag = 1;	
		}
		i--;
		j--; 
	}
	// 处理较大数的剩余部分 
	while( i >= 0 ){ 
		if(flag == 0){
			ans += s1[i];
		}
		else{
			int tmp = s1[i] - '0' - flag;
			ans += to_string(tmp);
			flag = 0;
		}
		i--; 
	}
	 // 翻转 
	reverse(ans.begin(),ans.end());
	//去除前导 0 
	int k = 0;
	while( k < ans.size() && ans[k] == '0') k++;
	if( k == ans.size() ){
		ans = "0";	
	}
	else ans = ans.substr(k);
	// 结果是否为负 
	return minus?"-" + ans:ans;
} 
 
int main() {
    string s1, s2;
    cin >> s1 >> s2;
    cout << sub(s1, s2) << endl;
    system("pause");
    return 0;
}
```

## 2. 大数乘法

```c++
//使用大小为 n + m 的数组，num1的第i位乘以num2的第j位，结果对应存放在数组的i+j+1的位置。
class Solution {
public:
    string multiply(string num1, string num2) {
        int n = num1.size();
        int m = num2.size();
        vector<int> result(n + m,0);//123 * 123
        for(int i = n - 1; i >= 0; i--){
            for(int j = m - 1;j >= 0; j--){
                int tmp = (num1[i] - '0') * (num2[j] - '0');
                tmp += result[i + j + 1];
                result[i + j] += tmp / 10;  //注意 这里是 +=
                result[i + j + 1] = tmp % 10;
            }
        }
        int i = 0;
        while( i < n + m && result[i] == 0 ){
            i++;
        }
        string ans;
        for(; i < n + m; i++){
            ans.push_back(result[i] + '0');
        }
        return ans.size() == 0?"0":ans;
    }
};
```

## 3. 翻转字符串 

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int end = s.size() - 1;
        int begin = 0;
        while( begin < end ){
            char c = s[begin];
            s[begin] = s[end];
            s[end] = c;
            begin++;
            end--;
        }
    }
};
```

## 4. 翻转字符串 II

```c++
/*给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。
如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
*/
class Solution {
public:
    void reverse(string &s,int begin,int end){
        while ( begin < end ){
            swap(s[begin],s[end]);
            begin++;
            end--;
        }
    }

    string reverseStr(string s, int k) {
        int n = s.size() - 1;
        int begin = 0;
        while ( 1 ){
            if( begin > n ) break;
            int len = n - begin + 1;
            if( len < k ) reverse(s,begin,n);
            else reverse(s,begin,begin + k -1);
            begin += 2*k;
        }
        return s;
    }
};
```

## 5. 替换空格

```c++
/*思路：首先扩充数组到每个空格替换成"%20"之后的大小。

然后从后向前替换空格，也就是双指针法，过程如下：

i指向新长度的末尾，j指向旧长度的末尾。*/

class Solution {
public:
    string replaceSpace(string s) {
        int len = s.size();
        int cnt = 0;
        for(auto &c : s ){
            if( c == ' '){
                cnt++;
            }
        }
        s.resize(len + 2 * cnt);
        for(int i = len - 1,j = s.size() - 1; i < j; i--,j--){
            if(s[i] != ' '){
                s[j] = s[i];
            }
            else{
                s[j - 2] = '%';
                s[j - 1] = '2';
                s[j] = '0';
                j -= 2;
            }
        }
        return s;
    }
};
```

## 6. 翻转字符串里的单词

```c++
//思路：字符串s整体反转，再逐个移位，反转单词。
class Solution {
public:
    string reverseWords(string s) {
        reverse(s.begin(),s.end());
        int pos = 0;
        int n = s.size();
        for(int start = 0; start < n; start++){
            if( s[start] != ' ' ){
                int end = start;
                // 填一个空白字符然后将pos移动到下一个单词的开头位置
                if( pos != 0) s[pos++] = ' ';
                // 循环遍历至单词的末尾
                while( end < n && s[end] != ' ')    s[pos++] = s[end++];
                // 反转整个单词
                reverse(s.begin() + pos - (end - start),s.begin() + pos);
                // 更新start，去找下一个单词
                start = end ;
            }
        }
        //删除多余位置
        s.erase(s.begin() + pos,s.end());
        return s;
    }
};
```

## 7. 左旋转字符串

```c++
//思路：先局部反转前n个字符串和剩余字符串，再整体反转。
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        //反转前n个字符串
        reverse(s.begin(),s.begin() + n);
        //反转剩余字符串
        reverse(s.begin() + n,s.end());
        //整体反转
        reverse(s.begin(),s.end());
        return s;
    }
};
```

## 8. 28 实现 strStr()-KMP算法

字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**；**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。

**//前缀表统一减一 C++代码实现**

```c++
/*思路：利用前缀表即next数组
前缀表有什么作用呢？
前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。

复杂度分析
时间复杂度：O(n+m)，其中 n是字符串haystack 的长度，m 是字符串needle 的长度。我们至多需要遍历两字符串一次。
空间复杂度：O(m)，其中 m是字符串needle 的长度。我们只需要保存字符串needle 的前缀函数。*/

class Solution {
public: 
    void getnext(int *next,const string &s){
        int j = -1;
        int n = s.size();
        next[0] = j;// 此行容易忘记
        for (int i = 1; i < n; i++){
            //前后缀不同
            while (j >= 0 && s[ i ] != s[j + 1]){
                j = next[j];//回退
            }
            //找到相同前后缀
            if (s[i] == s[j + 1]){
                j++;
            }
            next[i] = j;
        }
    }

    int strStr(string haystack, string needle) {
        if(needle.size() == 0) return 0;
        int next[needle.size()];
        getnext(next,needle);
        int j = -1;
        for (int i = 0 ;i < haystack.size(); i++){
            //不匹配
            while(j >= 0 && haystack[i] != needle[j + 1]){
                j = next[j];//寻找之后的匹配
            }
            //匹配,i,j同时后移
            if( haystack[i] == needle[j + 1]){
                j++;//i的增加在for循环里面
            }
            if(j == needle.size() -1){// j移动到了模式串的末尾，文本串s里出现了模式串t
                return i - j;//当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置
            }
        }
        return -1;
    }
};
```

**前缀表（不减一）C++实现**

那么前缀表就不减一了，也不右移的，到底行不行呢？行！

我之前说过，这仅仅是KMP算法实现上的问题，如果就直接使用前缀表可以换一种回退方式，找j=next[j-1] 来进行回退。

主要就是j=next[x]这一步最为关键！

```c++
class Solution{
public:
    void getnext(int *next,const string &s){
     	int j = 0;
        next[0] = j;// 此行容易忘记
        for (int i = 1; i < s.size(); i++){
            while( j >= 1 && s[i] != s[j]){
                j = next[j - 1];
            }
            if(s[i] == s[j]){
                j++;
            }
            next[i] = j;
        }
    }
    
    int strStr(string haystack,string needle){
        if(needle.size() == 0) return 0;
        int j = 0;
        int next[needle.size()];
        getnext(next,needle);
        for(int i = 0; i < haystack.size(); i++){
            while(j >= 1 && haystack[i] != needle[j]){
                j = next[j - 1];
            }
            if(haystack[i] == needle[j]){
                j++;
            }
            if(j == needle.size() ){
                return i - j + 1 ;
            }
        }
        return -1;
    }
};
```

## 9. 459重复的子字符串

```c++
//思路：,求出前缀表，然后数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。
class Solution {
public:
    void getnext(int *next,const string&s){
        int j = -1;
        next[0] = j;//起始位置为-1，此行容易忘记
        for(int i = 1; i < s.size(); i++){
            while (j >= 0 && s[i] != s[j + 1]){
                j = next[j];
            }
            if (s[i] == s[j + 1]){
                j++;
            }
            next[i] = j;
        }
    }

    bool repeatedSubstringPattern(string s) {
        int len = s.size();
        int next[len];
        getnext(next,s);
        if(next[len - 1] != -1 && len % (len - (next[len - 1] + 1)) == 0){
            return true;
        }
        return false;
    }
};
```

## [10. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

```c++
class Solution {
public:
    int myAtoi(string s) {
        long long res = 0;
        int flag = 1;
        int i = 0;
        while( s[i] == ' ') i++;
        if( s[i] == '-' ) flag = -1;
        if( s[i] == '-' || s[i] == '+' ) i++;
        int n = s.size();
        while ( i < n && isdigit(s[i]) ) {
            int tmp = s[i] - '0';
            if( res > INT_MAX / 10 || ( res == INT_MAX / 10 && tmp > 7 ) )
                return flag == 1?INT_MAX:INT_MIN;
            res = res * 10 + tmp;
            i++;
        }
        return flag == 1?res:-res;
    }
};
```

## 11.[214. 最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/)

```c++

    /*思路  如对于串 abcd 想要将其变为回文串
      那么先把它逆序 然后放在前面 自然是回文了 
                                   abcd
                               dcba
                               dcbaabcd ->是回文
      但是我们发现根本没必要放这么多在前面 因为abcd的前缀和dcab的后缀有重合(如a) 所以为了只添加最少       的字符,我们在前方只需要添加不重复的即可
                                    abcd
                                 dcba
                                 dcbabcd ->依然是回文
     //为了添加的最少 我们就需要找到dcba的后缀和abcd的前缀重合的部分，且让重合部分最大即可
     //故而联想到kmp算法，它的next数组就是用来求一个串的前缀和后缀相同的长度的最大值
     //所以拼接起字符串 abcddcba 但是我们所求的前缀是不能超过中点的，因此用一个特殊字符隔开
     //           即为 abcd#dcba 这样在匹配前后缀时，相同长度就一定不会超过#号了
     //           这样问题就转化为了 求abcd#dcba的next数组 易知该串的前后缀相同时的最大长度为1
                此时的最长相同前后缀即为a   和  a  
                                     所以把后半部分除去重叠的部分拼接到前半部分即可
                            答案就是  dcbabcd
                                     大功告成!
                  
     */
    string shortestPalindrome(string s) {
        string revs = s;//存s的逆序
        int tn = s.size();//中点处,#前面的位置
        reverse(revs.begin(),revs.end());
        s = ' '+ s + '#' + revs;//让下标从1开始
        int n = s.size()-1;//实际长度
        vector<int> ne(n+1);//next数组
        for(int i = 2, j = 0; i <= n; i++){//求next数组 
            while(j&&s[i]!=s[j+1]) j = ne[j];
            if(s[i]==s[j+1]) j++;
            ne[i] = j;
        }
        return s.substr(tn+2,tn-ne[n])+s.substr(1,tn);//后半部分除去重叠后缀+前半部分
    }
```



# 5.栈与队列

## 1. [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

```c++
//思路:两个栈，一个Stackin，另一个Stackout
class MyQueue {
private:
    stack<int>s1;
    stack<int>s2;
public:
    /** Initialize your data structure here. */
    MyQueue() {
   
    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        s1.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(s2.empty()){
            while (!s1.empty()){
                int tmp = s1.top();
                s1.pop();
                s2.push(tmp);
            }
        }
        int tmp = s2.top();
        s2.pop();
        return tmp;
    }
    
    /** Get the front element. */
    int peek() {
        //调用自身pop()
        int tmp = this->top();
        s2.push(tmp);
        return tmp;    
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return s2.empty() && s1.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

## 2. [225 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

```c++
//两个队列，q1存放栈元素，q2为辅助栈
class MyStack {
public:
    queue<int> q1;
    queue<int> q2;
    /** Initialize your data structure here. */
    MyStack() {

    }
    
    /** Push element x onto stack. */
    void push(int x) {
        q2.push(x);
        while (!q1.empty()){
            q2.push(q1.front());
            q1.pop();
        }
        swap(q1,q2);
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int tmp = q1.front();
        q1.pop();
        return tmp;
    }
    
    /** Get the top element. */
    int top() {
        return q1.front();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return q1.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

```c++
//思路：一个队列实现
class MyStack {
public:
    queue<int> q;
    /** Initialize your data structure here. */
    MyStack() {

    }
    
    /** Push element x onto stack. */
    void push(int x) {
        q.push(x);
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int n = q.size();
        n--;
        while (n--){
            int tmp = q.front();
            q.pop();
            q.push(tmp);
        }
        int ans = q.front();
        q.pop();
        return ans;
    }
    
    /** Get the top element. */
    int top() {
        return q.back();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return q.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

## [3. 20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```c++
//思路：使用栈,左括号入栈，右括号匹配左括号
class Solution {
public:
    bool is_ok(char a,char b){
        if( (a=='[' && b == ']' ) || ( a=='(' && b == ')' ) || (a=='{' && b == '}'  ) )            return true;
        return false;
    }

    bool isValid(string s) {
        stack<char> stk;
        for (int i = 0; i < s.size(); i++){
            if (s[i] == ')' || s[i] == '}' || s[i] == ']'){
                if(stk.empty()) return false;
                char tmp = stk.top();
                if ( is_ok(tmp,s[i]) ) stk.pop();
                else return false;
            }
            else{
                stk.push(s[i]);
            }
        }
        return stk.empty();
    }
};
         
```

## [4.1047 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

```c++
//string 替代 栈的作用
class Solution {
public:
    string removeDuplicates(string s) {
        string result;
        for(char c : s) {
            if(result.empty() || result.back() != c) {
                result.push_back(c);
            }
            else {
                result.pop_back();
            }
        }
        return result;
    }
};
```

```c++
//使用栈
class Solution {
public:
    string removeDuplicates(string s) {
        stack<int> stk;
        for(auto &c : s){
            if(stk.empty() || c != stk.top()){
                stk.push(c);
            }
            else stk.pop();
        }
        string ans;
        while(!stk.empty()){
            ans += stk.top();
            stk.pop();
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
};
```

## 5.[150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

```c++
//思路：利用栈
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> stk;
        for(auto &str : tokens){
            if(str == "+" || str == "-" || str == "*" || str == "/"){
                int n1 = stk.top();stk.pop();
                int n2 = stk.top();stk.pop();
                if( str == "+" ){
                    stk.push(n2 + n1);
                }
                else if(str == "-" ){
                    stk.push(n2 - n1);
                }
                else if(str == "*"){
                    stk.push(n2 * n1);
                }
                else stk.push(n2 / n1);
            }
            else{
                stk.push(atoi(str.c_str());//使用库函数 atoi() c_str() stoi() string -> int
            }
        }
        return stk.top();
    }
};
```

## 6.239 滑动窗口最大值

```c++
/*思路：
   当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果前者大于等于后者，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。
   由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。但与方法一中相同的是，此时的最大值可能在滑动窗口左边界的左侧，并且随着窗口向右移动，它永远不可能出现在滑动窗口中了。因此我们还需要不断从队首弹出元素，直到队首元素在窗口中为止。
   为了可以同时弹出队首和队尾的元素，我们需要使用双端队列。满足这种单调性的双端队列一般称作「单调队列」。*/
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        deque<int> q;
        for (int i = 0; i < k; i++){
            while ( !q.empty() && nums[i] >= nums[q.back()] ){
                q.pop_back();
            }
            q.push_back(i);
        }
        vector<int>ans;
        ans.push_back(nums[q.front()]);
        for (int i = k; i < n; i++){
            while ( !q.empty() && nums[i] >= nums[q.back()] ){
                q.pop_back();
            }
            q.push_back(i);
            while ( !q.empty() && q.front() <= i - k ){
                q.pop_front();
            }
            ans.push_back(nums[q.front()]);
        }
        return ans;
    }
};

//时空复杂度：o(n)
```



```c++
class Solution {
private:
    class MyQueue { //单调队列（从大到小）
    public:
        deque<int> que; // 使用deque来实现单调队列
        // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
        // 同时pop之前判断队列当前是否为空。
        void pop(int value) {
            if (!que.empty() && value == que.front()) {
                que.pop_front();
            }
        }
        // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
        // 这样就保持了队列里的数值是单调从大到小的了。
        void push(int value) {
            while (!que.empty() && value > que.back()) {
                que.pop_back();
            }
            que.push_back(value);

        }
        // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
        int front() {
            return que.front();
        }
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyQueue que;
        vector<int> result;
        for (int i = 0; i < k; i++) { // 先将前k的元素放进队列
            que.push(nums[i]);
        }
        result.push_back(que.front()); // result 记录前k的元素的最大值
        for (int i = k; i < nums.size(); i++) {
            que.pop(nums[i - k]); // 滑动窗口移除最前面元素
            que.push(nums[i]); // 滑动窗口前加入最后面的元素
            result.push_back(que.front()); // 记录对应的最大值
        }
        return result;
    }
};

```

## [7. 347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

```c++
//哈希表 + 优先队列
/*
大家对这个比较运算在建堆时是如何应用的，为什么左大于右就会建立小顶堆，反之建立大顶堆比较困惑。

确实 例如我们在写快排的cmp函数的时候，return left>right 就是从大到小，return left<right 就是从小到大。

优先级队列的定义正好反过来了，可能和优先级队列的源码实现有关（我没有仔细研究），我估计是底层实现上优先队列队首指向后面，队尾指向最前面的缘故！*/
class Solution {
public:
    unordered_map<int,int>m;
		static  bool cmp(pair<int,int>&a,pair<int,int>&b){
       		return a.second>b.second;
    }
    
    vector<int> topKFrequent(vector<int>& nums, int k) {
       priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);
        for(auto i:nums){
            m[i]++;	
        }
        for(auto it=m.begin();it!=m.end();it++){
            if(q.size()==k){
                if(q.top().second < it->second){
                    q.pop();
                    q.emplace(it->first,it->second);
                }
            }
            else{
                 q.emplace(it->first,it->second);
            }
        }
    	vector<int>v;
    	while(!q.empty()){
        	v.push_back(q.top().first);
         	q.pop();
    	}
    	return v;
    }  
};
```

```c++
class Solution {
public:
    unordered_map<int,int>mp;
    
    struct cmp{//重写仿函数
       bool operator()(pair<int,int>&a,pair<int,int>&b)const{
            return  a.second > b.second;
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        priority_queue<pair<int, int>,vector<pair<int,int>>,cmp> q;
        for (int i = 0; i < nums.size(); i++){
            mp[nums[i]]++;
        }

        for (unordered_map<int,int>::iterator it = mp.begin(); it != mp.end(); it++){
            if(q.size() < k)
                q.push(pair<int,int>(it->first,it->second));
            else{
                if( q.top().second < it->second  ){
                    q.pop();
                    q.push(pair<int,int>(it->first,it->second));
                }
            }
        }
        vector<int> ans;
        while(!q.empty()){
            ans.push_back(q.top().first);
            q.pop();
        }
        return ans;
    }
};
```

# 6.二叉树

## 1 . [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution{
public:

    vector<int> preorderTraversal(TreeNode* root) {
        vector<int>ans;
        if(root == nullptr) return ans;
        stack<TreeNode*> stk;
        TreeNode* tmp = root;
        while( !stk.empty() || tmp !=nullptr ){
            //入栈
            while( tmp!= nullptr ){
                ans.push_back(tmp->val);
                stk.push(tmp);
                tmp = tmp->left;
            }
            //出栈
            tmp = stk.top();
            stk.pop();
            tmp = tmp->right;
        }
        return ans;
    }
};

// 第二种
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左
                st.push(node);                          // 中
                st.push(NULL);
            } 
            else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};

```

## 2. [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int>ans;
        if( root == nullptr) return ans;
        stack<TreeNode*>stk;
        TreeNode* node = root;
        while( !stk.empty() || node != nullptr ){
            while( node != nullptr){
                stk.push(node);
                node = node->left;
            }
            node = stk.top();
            stk.pop();
            ans.push_back(node->val);
            node = node->right;
        }
        return ans;
    }
};
// 第二种
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

                st.push(node);                          // 添加中节点
                st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

                if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
            }
            else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.top();    // 重新取出栈中元素
                st.pop();
                result.push_back(node->val); // 加入到结果集
            }
        }
        return result;
    }
};

```

## 3. [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```c++
// 第二种
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // 中
                st.push(NULL);

                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左

            } 
            else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};

```

## 4. [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */ 

//go版本
func invertTree(root *TreeNode) *TreeNode {
    if root == nil{
        return nil
    }
    tmp := root.Left
    root.Left = root.Right
    root.Right = tmp
    invertTree(root.Left)
    invertTree(root.Right)
    return root
}
```

## 5.[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

```c++
class Solution {
public:
    bool check(TreeNode *u, TreeNode *v) {
        queue <TreeNode*> q;
        q.push(u); q.push(v);
        while (!q.empty()) {
            u = q.front(); q.pop();
            v = q.front(); q.pop();
            if (!u && !v) continue;
            if ((!u || !v) || (u->val != v->val)) return false;

            q.push(u->left); 
            q.push(v->right);

            q.push(u->right); 
            q.push(v->left);
        }
        return true;
    }

    bool isSymmetric(TreeNode* root) {
        return check(root, root);
    }
};
```

```go
func isSymmetric(root * TreeNode) bool {
    u,v := root,root
    q := []*TreeNode{}
    q = append(q,u)
    q = append(q,v)
    for len(q) > 0 {
        u,v := q[0],q[1]
        q = q[2:]
        if u == nil && v == nil {
            continue
        }
        if u == nil || v == nil {
            return false
        }
        if u.val != v.val {
            return false
        }
        q = append(q,u.Left)
        q = append(q,v.Right)
        
        q = append(q,u.Right)
        q = append(q,v.Left)
    }
    return true
}
```

## 6. [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
// go 语言

func maxDepth(root *TreeNode) int {
    if root == nil{
        return 0
    }
    return max(maxDepth(root.Left) , maxDepth(root.Right)) + 1
}

func max(a,b int) int {
    if a > b{
        return a
    }else{
        return b
    }
}
```

## 7. [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        if(root->left== nullptr && root->right == nullptr)  return 1;
        int mindeep = INT_MAX;
        if(root->left) mindeep = min(minDepth(root->left)+1,mindeep);
        if(root->right) mindeep = min(minDepth(root->right)+1,mindeep);
        return mindeep;
    }
};
```

## 8. [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```c++
/* 二分查找 + 位运算
 等比数列求和 Sn = a1*(1-q^n)/(1-q)  ;对于最大层数为 h 的完全二叉树，节点个数一定在 [2^h,2^(h+1)-1]的范围内，可以在该范围内通过二分查找的方式得到完全二叉树的节点个数。
*/
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int level = 0;
        TreeNode* node = root;
        while (node->left != nullptr) {
            level++;
            node = node->left;
        }
        int low = 1 << level, high = (1 << (level + 1)) - 1;
        while (low < high) {
            int mid = (high - low + 1) / 2 + low;
            if (exists(root, level, mid)) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }

    bool exists(TreeNode* root, int level, int k) {
        int bits = 1 << (level - 1);
        TreeNode* node = root;
        while (node != nullptr && bits > 0) {
            if (!(bits & k)) {
                node = node->left;
            } else {
                node = node->right;
            }
            bits >>= 1;
        }
        return node != nullptr;
    }
};

```

## [9. 110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

```c++
class Solution {
public:
    int deep(TreeNode* root){
        if(root == nullptr) return 0;
        int deep_left = deep(root->left) ;
        int deep_right = deep(root->right) ;
        if( deep_left == -1 || deep_right == -1 || abs(deep_left - deep_right) > 1 ) {
            return -1;
        }
        return max(deep_left,deep_right) + 1;
    }

    bool isBalanced(TreeNode* root) {
        return deep(root) != -1;
    }
};
```

## 10. [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```c++
class Solution {
public:
    void dfs(TreeNode*root,string path,vector<string>& ans){
        if(root == nullptr) return;
        path += to_string(root->val);
        if(root->left == nullptr && root->right == nullptr){
            ans.push_back(path);
            return;
        }
        dfs(root->left,path + "->",ans);
        dfs(root->right,path + "->",ans);
    }

    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> ans;
        dfs(root,"",ans);
        return ans;
    }
};
```

## 11. [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

```go
//二叉树左叶子节点之和
var sum int

func dfs(root * TreeNode,flag int) {
    if root == nil{
        return
    }
    if flag == 1 && root.Left == nil && root.Right == nil {
        sum += root.Val
    }
    dfs(root.Left,1);
    dfs(root.Right,0);
}

func sumOfLeftLeaves(root *TreeNode) int {
    if root == nil {
        return 0
    }
    sum = 0
    dfs(root,0)
    return sum
}
```

## 12 [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

```go
func dfs(root *TreeNode,deep int,ans,high *int){
    if root == nil {
        return 
    }
    if root.Left == nil && root.Right == nil {
        if deep > *high {
            *ans = root.Val
            *high = deep
            return
        }
    }
    dfs(root.Left,deep + 1,ans,high)
    dfs(root.Right,deep + 1,ans,high)
}

func findBottomLeftValue(root *TreeNode) int {
    if root.Left == nil && root.Right == nil{
        return root.Val
    }
    ans ,high := 0,0
    dfs(root,0,&ans,&high)
    return ans
}
```

## 13. [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
//判断路径总和是否等于tatgetsum
class Solution {
public:

    bool dfs(TreeNode* root,int targetSum,int sum){
        if( root == nullptr ) return false;
        sum += root->val;
        if(!root->left && !root->right && targetSum == sum){
            return true;
        }
        if( dfs(root->left,targetSum,sum) || dfs(root->right,targetSum,sum ) ){
            return true;
        }
        return false;
    }

    bool hasPathSum(TreeNode* root, int targetSum) {

        if( root == nullptr ) return false;

        return dfs(root,targetSum,0);
        
    }
};

//迭代解法
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        if (root == nullptr) {
            return false;
        }
        queue<TreeNode *> que_node;
        queue<int> que_val;
        que_node.push(root);
        que_val.push(root->val);
        while (!que_node.empty()) {
            TreeNode *now = que_node.front();
            int temp = que_val.front();
            que_node.pop();
            que_val.pop();
            if (now->left == nullptr && now->right == nullptr) {
                if (temp == sum) {
                    return true;
                }
                continue;
            }
            if (now->left != nullptr) {
                que_node.push(now->left);
                que_val.push(now->left->val + temp);
            }
            if (now->right != nullptr) {
                que_node.push(now->right);
                que_val.push(now->right->val + temp);
            }
        }
        return false;
    }
};

```



## 14. [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    int base, count, maxCount;

    void update(int x) {
        if (x == base) {
            ++count;
        } else {
            count = 1;
            base = x;
        }
        if (count == maxCount) {
            ans.push_back(base);
        }
        if (count > maxCount) {
            maxCount = count;
            ans = vector<int> {base};
        }
    }
    vector<int> findMode(TreeNode* root) {
        if(!root) return {};
        stack<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            TreeNode* node = q.top();
            if(node){
                q.pop();
                if(node->right) q.push(node->right);
                q.push(node);
                q.push(nullptr);
                if(node->left) q.push(node->left);
            }
            else{
                q.pop();
                node = q.top();
                q.pop();
                update(node->val);
            }
        }
        return ans;
    }
};
```

# 7.动态规划

#### 1 [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

```c++
//根据正负性讨论
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int maxF = nums[0],minF = nums[0],ans = nums[0];
        for (int i = 1;i < n;i++) {
            int mi = minF;
            int mn = maxF;
            maxF = max(mn * nums[i], max(mi * nums[i], nums[i] ) );
            minF = min(mi * nums[i], min(mn * nums[i], nums[i] ) );
            ans = max(ans,maxF); 
        }
        return ans;
    }
};
```

#### [2. 1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

```c++
// afece
//ace
//dp[i][j] 表示 {text}_1[0:i] 和 {text}_2[0:j]的最长公共子序列的长度。

class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector< vector<int> >dp(n+1,vector<int>(m+1,0));
        for(int i = 1;i < n+1;i++){
            for(int j = 1;j < m+1;j++){
                if(text1[i - 1] == text2[j - 1] )
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else 
                    dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]);
            }
        }
        return dp[n][m];
    }
};
```

#### [3. 300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```c++
//动态规划 dp[i] 表示前i+1个元素的最长递增子序列，包含位置0
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = (int)nums.size();
        if (n == 0) {
            return 0;
        }
        vector<int> dp(n, 0);
        for (int i = 0; i < n; ++i) {
            dp[i] = 1;
            for (int j = 0; j < i; ++j) {
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
};

//贪心+二分
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int>d(n + 1,0);
        if ( n == 0) return 0;
        int len = 1;
        d[len] = nums[0];
        for (int i = 1;i < n;i++) {
            if ( d[len] < nums[i]) {
                d[++len] = nums[i];
            }
            else {
                int l = 1, r = len;
                int pos = 0;
                while ( l <= r ) {
                    int mid = (l+r)>>1;
                    if ( d[mid] < nums[i] ) {
                        l = mid + 1;
                        pos = mid;
                    }
                    else {
                        r = mid - 1;
                    }
                }
                d[pos + 1] = nums[i];
            }
        }
        return len;
    }
};

```

#### 4 . [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

```c++
/*
给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-palindromic-subsequence
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/
//用dp[i][j] 表示字符串s的下标范围[i,j] 内的最长回文子序列的长度
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>>dp(n,vector<int>(n,0));
        for(int i = n - 1;i >= 0 ;i-- ) {
            dp[i][i] = 1;
            for(int j = i + 1;j < n;j++ ) {
                if(s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                }
                else {
                    dp[i][j] = max(dp[i + 1][j],dp[i][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
};
```

#### 5. [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

```c++
//动态规划
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if ( n == 0 ) {
            return 0;
        }
        
        vector<int> leftMax(n);
        leftMax[0] = height[0];
        for (int i = 1; i < n; i++) {
            leftMax[i] = max(leftMax[i - 1], height[i]);
        }

        vector<int> rightMax(n);
        rightMax[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            rightMax[i] = max(rightMax[i + 1], height[i]);
        }

        int ans = 0;
        for ( int i = 0; i < n; i++ ) {
            ans += min(leftMax[i], rightMax[i]) - height[i];
        }
        return ans;
    }
};
```

```c++
//双指针，leftmax < rightmax ，看作是两块挡板
class Solution {
public:
    int trap(vector<int>& height) {
       int ans = 0;
       int left = 0,right = height.size() - 1;
       int leftmax = 0,rightmax = 0;
       while ( left < right ) {
           leftmax = max(leftmax, height[left]);
           rightmax = max(rightmax, height[right]);
           if ( leftmax < rightmax ) {
                ans += leftmax - height[left];
                ++left;
           }
           else {
               ans += rightmax - height[right];
               --right;
           }
       }
        return ans;
    }
};
```

#### 6. [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int pre = nums[0];
        int ans = nums[0];
        for (int i = 1;i < nums.size() ;i++ ) {
            pre = max(pre + nums[i], nums[i]);
            ans = max(pre, ans);
        }
        return ans;
    }
};
```

# 8.排序算法

## 1）快速排序

https://www.cnblogs.com/fengty90/p/3768827.html

```c++
/* 平均情况nlog(n),最坏情况：o(n^2),最好情况：nlog(n);不稳定
快速排序最优的情况就是每一次取到的元素都刚好平分整个数组。
最糟糕情况下的快排，当待排序的序列为正序或逆序排列时
*/
void quick_sort(vector<int> vec,int left,int right){
    if( left >= high ) return;
    int i = left;
    int j = right;// right =  vec.size()
    int key = vec[left]; // 1 2 3 4 8 7 6 5
    while( 1 ) {
        while ( arr[++i] < key && i < high ); // 从前往后，找第一个比key大的数 
        while ( arr[--j] > key && j > left ); // 从后往前，找第一个比key小的数 
        if( i >= j ) break;
        swap(i, j);
    }
    swap(arr, j, low);
    quick_sort(vec, left, j - 1);
    quick_sort(vec, j + 1, right);
}
```

## 2) 归并排序

https://www.cnblogs.com/chengxiao/p/6194356.html

```c++
/*归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log^2(n)|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。 空间复杂度o(n) */
void mergesort(int *data, int begin, int end, int *temp){
 	if ( begin == end ) return;
	int mid = (end + begin) / 2;
	int k = 0; 				//临时数组指针
	int i = begin;			//左序列指针
	int j = mid + 1;		//右序列指针
	mergesort(data, begin, mid, temp);
	mergesort(data, mid + 1, end, temp); 
    //合并主流程
	while ( i <= mid && j <= end ){
		if(data[i] <= data[j]){
			temp[k++] = data[i++];
		}
		else{
			temp[k++] = data[j++];
		}
	}
	while (i <= mid){
		temp[k++] = data[i++];	//将左边剩余元素填充进temp中
	}
	while (j <= end){
		temp[k++] = data[j++];//将右序列剩余元素填充进temp中
	}
   //将temp中的元素全部拷贝到原数组中
	memcpy(&data[begin], temp, sizeof(int) * (end - begin + 1) );

}

```

## 3)堆排序

```c++
//不稳定
class Solution {
public:
    void maxHeapify(vector<int>& a, int i, int heapSize) { //下溯 
        int l = i * 2 + 1; //左 
		int r = i * 2 + 2; //右 
		int largest = i;   //根  
        if (l < heapSize && a[l] > a[largest]) {
							//a[l] <a[largest]	  自建小顶堆 
            largest = l;
        } 
        if (r < heapSize && a[r] > a[largest]) {
            				//a[r] <a[largest]	  自建小顶堆 
			largest = r;	
        }
        if (largest != i) {
            swap(a[i], a[largest]); 
            maxHeapify(a, largest, heapSize); //不断调整堆 
        }
    }
    
    void buildMaxHeap(vector<int>& a, int heapSize) {
        for (int i = heapSize / 2 ; i >= 0; --i) {
            maxHeapify(a, i, heapSize);
        } 
    }

    int findKthLargest(vector<int>& nums, int k) {
        int heapSize = nums.size();
        //初始建堆
        buildMaxHeap(nums, heapSize);
        
        for (int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {
        		swap(nums[0], nums[i]);
            	--heapSize;
            	maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }
};
```

## 4)插入排序

```c++
//稳定 o(n^2)
void insertionSort(vector<int>& arr) {
    for (int i = 1;i < arr.size();i++ ) {
        int j = i;
        while ( j > 0 && arr[j] < arr[j - 1] ) {
            swap(arr, j, j - 1);
            j--;
        }
    }
}
```

## 5)冒泡排序

```

```



# 9.图论

## 1.D算法

```c++
//最短路径算法 - D算法 ,用于单源最短路
int g[N][N], dis[N], n, m;//g[N][N]为邻接矩阵用于存储每条边，dis[N]存储某个点到1号点的最小距离， n为点数，m为边数
bool visit[N];//储存每个点的最短路是否确定

int dijkstra()
{
    memset(dis, 0x3f, sizeof(dis));
    dis[1] = 0;
    
    for(int i = 0; i < n - 1; i++)
    {
        int t = -1;//在未确定最短路的点中寻找距离一号店点最近的点
        for(int j = 1; j <= n; j ++)
        {
            if(!visit[j] && (t == -1 || dis[t] > dis[j]))
                t = j;
        }

        visit[t] = true;
        //用t更新其他点的距离
        for(int j = 1; j <= n; j++)
        {
            dis[j] = min(dis[j], dis[t] + g[t][j]);
        }
    }
    return dis[n];
}

```

# **智能指针实现**



# **memcpy实现**

```c++
void* memcpy(void* dest,void* sec,unsigned int n ){
	if ( dest == null || src == null ) {
        return null;
    }
	char* pdest = (char*) dest;
    char* psrc = (char*) src;
    while ( n-- ) {
        *pdest = *dest;
        *psrc = *src;
    }
    return pdest;
}
```

